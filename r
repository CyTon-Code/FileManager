Этот терминал преднозначен для работы с файлами.
Основные его задачи это делать какие то действия и отдавать внятные отчеты.

Терминал будет разбит на ядро и внутренние модули, которые могут быть полезны даже вам.
Ядро терминала это всеголишь интерфейс взаимодействия пользователя с всеми модулями, создавая прочную
структуру. В ядре с инструментов взимодействия с файлами это будет только импортация.

Тоесть если вы не пользователь, а разработчик вы спокойно можите изучить документацию нужного модуля и возпользоваться
им евдаваясь в подробности самого терминала.

ANT будет писан на языке python, потому что:
.Легко модифицировать.
.Язык не строг к ошибкам(этим буду часто пользоваться).

Терминал будет добро запускать ваши команды 3 способами.
Это скрипт-файл, это ввод вручную, это ввод в аргументы ANT при запуске.

Чесно говоря я хотел переписать после на С++, но пока что не тот уровень абстракций.

В этой папке скрипт main.py - приложение для работы с файлами
def - Ваши модули. Возвращают int.
sys - Встроенные модули. Возвращают bool или Exception или NoneType.
fun - Дополнительые модули. Непредсказуемые типы.
ants - Исполняемые файлы терминалом.
data - Общие ресурсы всех модулей.
r или r.r - файл описания папки или модуля.

Модули хранимые в def, первым параметром всегда принимают свой адресс
Адресс нужен для использования баз данных и прочих нужд.

общеизвестная папка - адрес константа.
виды подключения модулей:
Перемещение в общеизвестную папку(+переименование оригинала) /work/cut.{type} и обратно
Копирование в общеизвестную папку(+переименование копии) /work/lib.{type} и удаления копии
Запись адреса в sys.path и удаления от-туда, после использования.

Пока что я буду рекомендовать и оставлю по умолчанию способ с копированием, он наиболее безопасен, это будет до тех пор пока не будет реализован сам третий способ, который наиболее эффективен для локальных модулей.
Локальная работа: Работая с path (в рамках одного исполнителя с упором на скорость).
Глобальная работа: Копирование (Принцип хорош для одновременной работы с модулями несколькими исполнителями).
Публичная работа: перемещение (В рамках одного исполнителя).


Каждый запуск исполнителя, принуждает остановится предыдущего исполнителя, а также требует ввести новый текст(ну или это будет рандомно, также нельзя создавать ключи которе уже есть) для генерации ключа личности(от него будет генерироваться личная папка и прочие ресурсы, которые помогут работать одновременно нескольким терминалам не мешая друг другу, но все терминалы обьязаны общаться друг с другом - когда дойдет до этого момента нужно изучать общение через ОС а не файл.)

Принципы работы(копирование, перемещение или запись) не зависят от модулей.
Первым делом что происходит:
Работы вызывают функцию запуска:
так же в свою очередь узнает тип модуля, по умолчанию я хочу чтобы были
только: С, СPP, PY разумеется независимо от регистра. Если тип иной то
пытаться запустить как PY(default).
Дальше происходит запуск модуля непосредственно импортируя его обработав
 нужной функцией подключения.
После исполнения происходит зачистка(это: или удаления ссылки из path,
 или удаления копии или перемещение модуля назад)



разновидности модулей:
их будет несколько: встроенные, внешние, дополнительные.
встроенные: возвращают такие возможные типы: NoneType, bool, Exception.
 Пишутся на python.
внешние: возвращают такие типы: int(main), float/int(old). CPP, C, PY.
дополнительные: вызываются как python(но если вы умеете, то можете
 по колдовать, чтобы python вызывал другие языки).Возвращают любые типы.

Большая часть встроенных  модулей импортируется прямиком в Терминал, но
вы можете их спокойно использовать в своих внешних модулях.

База данных, функции для работы с ним также будут представлены в виде
 дополнительных функций.

более нормальные предложения запуска:
пайтон разрешает запускать файл с консоли:
вводя имя python следующие слова это аргументы второму аргументу ссилке на скрипт

поэтому при запуске терминатора все аргументы кроме нулевого отправляются в аргументы скрипта


'' "" - для обьеденения пробелов
`` - строчка немедленного имполнения. результат вывода возвращается на
место кавычек.
Если закочить строку не закрывающей кавычкой, то вызывается \n> для
дописания текста. до exit или нужной кавычки
.. Дописание строки доплюсовывает до имеющайся строки и завыершится команддой ехит или конечным парным количеством кавычек

Новая политика ответов от встроенных модулей:
Модуль возвращает NoneType Если он выполнил задачу! Дальше тру и фалс, фалс достается случаю в котором ситуация хуже, тру же ситуации более частой. експшн кидается только за критической ситцации.







Внутренние. Модули
Внешние модули.
Дополнительные модули.

Internal. Modules
External modules.
Additional modules.